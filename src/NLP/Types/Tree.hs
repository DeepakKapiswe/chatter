{-# LANGUAGE OverloadedStrings #-}
module NLP.Types.Tree where

import Prelude hiding (print)
import Control.Applicative ((<$>), (<*>))
import Data.Text (Text)
import qualified Data.Text as T

import Test.QuickCheck (Arbitrary(..), listOf, elements)
import Test.QuickCheck.Instances ()

import NLP.Types.Annotations (POS(..), Token(..), AnnotatedText(..), TaggedSentence(..))
import qualified NLP.Types.Annotations as AN

-- | A sentence of tokens without tags.  Generated by the tokenizer.
-- (tokenizer :: Text -> Sentence)
data Sentence = Sent [Token]
  deriving (Read, Show, Eq)

instance Arbitrary Sentence where
  arbitrary = Sent <$> arbitrary

-- | Extract the token list from a 'Sentence'
tokens :: Sentence -> [Token]
tokens (Sent ts) = ts

-- | A chunked sentence has POS tags and chunk tags. Generated by a
-- chunker.
--
-- (chunker :: (Chunk chunk, Tag tag) => TaggedSentence tag -> ChunkedSentence chunk tag)
data ChunkedSentence chunk tag = ChunkedSent [ChunkOr chunk tag]
  deriving (Read, Show, Eq)

-- | A data type to represent the portions of a parse tree for Chunks.
-- Note that this part of the parse tree could be a POS tag with no
-- chunk.
data ChunkOr chunk tag = Chunk_CN (Chunk chunk tag)
                       | POS_CN   (tag)
                         deriving (Read, Show, Eq)

-- | A Chunk that strictly contains chunks or POS tags.
data Chunk chunk tag = Chunk chunk [ChunkOr chunk tag]
  deriving (Read, Show, Eq)

showChunkedSent :: (AN.Chunk c, POS t) => ChunkedSentence c t -> Text
showChunkedSent = T.pack . show
  -- T.intercalate " " (map showChunkOr cs)
  -- where
  --   showChunkOr (POS_CN    pos)         = show pos -- TODO Fix this; should show text also.
  --   showChunkOr (Chunk_CN (Chunk chunk cors)) =
  --     let front = T.concat ["[", AN.serializeChunk chunk]
  --         back = "]"
  --         bits = map showChunkOr cors
  --     in T.append (T.intercalate " " (front:bits)) back

instance (AN.Chunk c, Arbitrary c, Arbitrary t, POS t) =>
  Arbitrary (ChunkedSentence c t) where
  arbitrary = ChunkedSent <$> arbitrary

-- | Generate a Text representation of a TaggedSentence in the common
-- tagged format, eg:
--
-- TODO: see if this works.
-- > "the/at dog/nn jumped/vbd ./."
--
printTS :: POS t => TaggedSentence t -> Text
printTS ts = getText ts

-- | Remove the tags from a tagged sentence
-- stripTags :: POS t => TaggedSentence t -> Sentence
-- stripTags ts = fst $ unzipTags ts

-- | Extract the tags from a tagged sentence, returning a parallel
-- list of tags along with the underlying Sentence.
-- unzipTags :: POS t => TaggedSentence t -> (Sentence, [t])
-- unzipTags (TaggedSent ts) =
--   let (tags, toks) = unzip $ map topair ts
--       topair (POS tag tok) = (tag, tok)
--   in (Sent toks, tags)

-- unzipChunks :: (AN.Chunk c, POS t) => ChunkedSentence c t -> (TaggedSentence t, [c])
-- unzipChunks (ChunkedSent cs) = (TaggedSent poss, chunks)
--   where
--     (poss, chunks) = unzip (concatMap f cs)

-- --    f :: ChunkOr chunk tag -> [(POS tag, chunk)]
--     f (POS_CN                  postag) = [(postag, AN.notChunk)]
--     f (Chunk_CN (Chunk chTag subTree)) = map (updateChunk chTag) (concatMap f subTree)

-- --    updateChunk :: c -> (POS t, c) -> (POS t, c)
--     updateChunk chunk (ptag, oldChunk) | oldChunk == AN.notChunk = (ptag, chunk)
--                                        | otherwise               = (ptag, oldChunk)


-- | Combine the results of POS taggers, using the second param to
-- -- fill in 'tagUNK' entries, where possible.
-- combine :: POS t => [TaggedSentence t] -> [TaggedSentence t] -> [TaggedSentence t]
-- combine xs ys = zipWith combineSentences xs ys

-- -- | Merge 'TaggedSentence' values, preffering the tags in the first 'TaggedSentence'.
-- -- Delegates to 'pickTag'.
-- combineSentences :: POS t => TaggedSentence t -> TaggedSentence t -> TaggedSentence t
-- combineSentences xs ys =
--   TaggedSentence { tagTokSentence = tagTokSentence xs
--                  , tagAnnotations = zipWith pickAnnotation
--                                     (tagAnnotations xs)
--                                     (tagAnnotations ys)
--                  }
--   where
--     pickAnnotation :: Annotation TokenizedSentence t
--                    -> Annotation TokenizedSentence t
--                    -> Annotation TokenizedSentence t
--     pickAnnotation a1 a2 = 


instance (AN.Chunk c, Arbitrary c, Arbitrary t, POS t) => Arbitrary (ChunkOr c t) where
  arbitrary = elements =<< do
                chunk <- mkChunk <$> arbitrary <*> listOf arbitrary
                chink <- mkChink <$> arbitrary <*> arbitrary
                return [chunk, chink]

-- | Helper to create 'ChunkOr' types.
mkChunk :: (AN.Chunk chunk, POS tag) => chunk -> [ChunkOr chunk tag] -> ChunkOr chunk tag
mkChunk chunk children = Chunk_CN (Chunk chunk children)

-- | Helper to create 'ChunkOr' types that just hold POS tagged data.
mkChink :: (AN.Chunk chunk, POS tag) => tag -> Token -> ChunkOr chunk tag
mkChink tag token      = POS_CN tag


instance (AN.Chunk c, Arbitrary c, Arbitrary t, POS t) => Arbitrary (Chunk c t) where
  arbitrary = Chunk <$> arbitrary <*> arbitrary



-- | Extract the text of a 'Token'
showTok :: Token -> Text
showTok (Token txt) = txt


-- | Calculate the length of a 'TaggedSentence' (in terms of the
-- number of tokens).
tsLength :: POS t => TaggedSentence t -> Int
tsLength ts = length $ tagAnnotations ts

-- | True if the input sentence contains the given text token.  Does
-- not do partial or approximate matching, and compares details in a
-- fully case-sensitive manner.
contains :: POS t => TaggedSentence t -> Text -> Bool
contains ts tok = T.isInfixOf tok $ getText ts

-- | True if the input sentence contains the given POS tag.
-- Does not do partial matching (such as prefix matching)
-- containsTag :: POS t => TaggedSentence t -> t -> Bool
-- containsTag (TaggedSent ts) tag = any (posTagMatches tag) ts

-- | Compare the POS-tag token with a supplied tag string.
-- posTagMatches :: POS t => t -> POS t -> Bool
-- posTagMatches t1 (POS t2 _) = t1 == t2

-- -- | Compare the POS-tagged token with a text string.
-- posTokMatches :: POS t => Text -> POS t -> Bool
-- posTokMatches txt (POS _ tok) = tokenMatches txt tok

-- | Compare a token with a text string.
tokenMatches :: Text -> Token -> Bool
tokenMatches txt (Token tok) = txt == tok
